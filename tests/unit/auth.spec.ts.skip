/**
 * Copyright (c) 2024 Fluent Language Learning Extension. All Rights Reserved.
 * 
 * PROPRIETARY AND CONFIDENTIAL
 * 
 * This file is part of the Fluent Language Learning Extension and is the
 * proprietary and confidential property of the copyright holder. Unauthorized
 * copying, modification, distribution, or use of this file, via any medium,
 * is strictly prohibited.
 */

import { test, expect } from '@playwright/test';
import { InstallationAuth } from '../../src/features/auth/auth';
import { AUTH_CONSTANTS } from '../../src/shared/constants';

// Mock dependencies
vi.mock('../../src/shared/logger', () => ({
  logger: {
    info: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
    debug: vi.fn()
  }
}));

vi.mock('../../src/features/auth/crypto', () => ({
  secureCrypto: {
    generateInstallationId: vi.fn(() => 'test-installation-id'),
    generateToken: vi.fn(() => 'test-generated-token'),
    signRequest: vi.fn(() => 'test-signature')
  }
}));

// Mock chrome storage API
const mockStorage = {
  get: vi.fn(),
  set: vi.fn()
};

global.chrome = {
  storage: {
    local: mockStorage
  },
  runtime: {
    id: 'test-extension-id'
  }
} as any;

// Mock fetch
global.fetch = vi.fn();

describe('InstallationAuth', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockStorage.get.mockResolvedValue({});
    mockStorage.set.mockResolvedValue(undefined);
  });

  describe('Security Fix Verification', () => {
    test('should NOT fall back to debug authentication on 404', async () => {
      // Mock 404 response
      (global.fetch as any).mockResolvedValueOnce({
        ok: false,
        status: AUTH_CONSTANTS.HTTP_STATUS.NOT_FOUND,
        text: async () => 'Not found'
      });

      // Attempt initialization
      await expect(InstallationAuth.initialize()).rejects.toThrow(
        'Authentication service not available'
      );

      // Verify no debug auth was stored
      expect(mockStorage.set).not.toHaveBeenCalledWith(
        expect.objectContaining({
          [AUTH_CONSTANTS.STORAGE_KEY]: expect.objectContaining({
            installationId: 'debug-installation',
            token: 'fluent-extension-2024-shared-secret-key'
          })
        })
      );
    });

    test('should throw proper error messages for different status codes', async () => {
      const testCases = [
        {
          status: AUTH_CONSTANTS.HTTP_STATUS.NOT_FOUND,
          expectedError: 'Authentication service not available'
        },
        {
          status: AUTH_CONSTANTS.HTTP_STATUS.UNAUTHORIZED,
          expectedError: 'Authentication failed'
        },
        {
          status: AUTH_CONSTANTS.HTTP_STATUS.FORBIDDEN,
          expectedError: 'Authentication failed'
        },
        {
          status: AUTH_CONSTANTS.HTTP_STATUS.SERVER_ERROR,
          expectedError: 'temporarily unavailable'
        }
      ];

      for (const { status, expectedError } of testCases) {
        vi.clearAllMocks();
        (global.fetch as any).mockResolvedValueOnce({
          ok: false,
          status,
          text: async () => 'Error'
        });

        await expect(InstallationAuth.initialize()).rejects.toThrow(expectedError);
      }
    });
  });

  describe('Normal Authentication Flow', () => {
    test('should register new installation when no existing auth', async () => {
      // Mock successful registration
      (global.fetch as any).mockResolvedValueOnce({
        ok: true,
        status: AUTH_CONSTANTS.HTTP_STATUS.OK,
        json: async () => ({
          token: 'new-auth-token',
          expiresIn: 3600
        })
      });

      await InstallationAuth.initialize();

      // Verify registration was called
      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/auth/register'),
        expect.objectContaining({
          method: 'POST',
          headers: expect.objectContaining({
            'Content-Type': 'application/json'
          })
        })
      );

      // Verify auth was stored
      expect(mockStorage.set).toHaveBeenCalledWith(
        expect.objectContaining({
          [AUTH_CONSTANTS.STORAGE_KEY]: expect.objectContaining({
            token: 'new-auth-token'
          })
        })
      );
    });

    test('should use existing auth if not expired', async () => {
      const existingAuth = {
        installationId: 'existing-id',
        token: 'existing-token',
        createdAt: Date.now() - 1000, // 1 second ago
        lastRefreshed: Date.now() - 1000
      };

      mockStorage.get.mockResolvedValueOnce({
        [AUTH_CONSTANTS.STORAGE_KEY]: existingAuth
      });

      await InstallationAuth.initialize();

      // Should not make any API calls
      expect(global.fetch).not.toHaveBeenCalled();
    });

    test('should refresh token when needed', async () => {
      const oldAuth = {
        installationId: 'existing-id',
        token: 'old-token',
        createdAt: Date.now() - AUTH_CONSTANTS.TOKEN_REFRESH_INTERVAL_MS - 1000,
        lastRefreshed: Date.now() - AUTH_CONSTANTS.TOKEN_REFRESH_INTERVAL_MS - 1000
      };

      mockStorage.get.mockResolvedValueOnce({
        [AUTH_CONSTANTS.STORAGE_KEY]: oldAuth
      });

      // Mock successful refresh
      (global.fetch as any).mockResolvedValueOnce({
        ok: true,
        status: AUTH_CONSTANTS.HTTP_STATUS.OK,
        json: async () => ({
          token: 'refreshed-token',
          expiresIn: 3600
        })
      });

      await InstallationAuth.initialize();

      // Verify refresh was called
      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/auth/refresh'),
        expect.any(Object)
      );
    });
  });

  describe('getAuthHeaders', () => {
    test('should return proper auth headers', async () => {
      const auth = {
        installationId: 'test-id',
        token: 'test-token',
        createdAt: Date.now(),
        lastRefreshed: Date.now()
      };

      mockStorage.get.mockResolvedValueOnce({
        [AUTH_CONSTANTS.STORAGE_KEY]: auth
      });

      const headers = await InstallationAuth.getAuthHeaders();

      expect(headers).toEqual({
        'Authorization': 'Bearer test-token',
        'X-Installation-Id': 'test-id',
        'X-Timestamp': expect.any(String),
        'X-Signature': 'test-signature'
      });
    });

    test('should throw error when no auth available', async () => {
      mockStorage.get.mockResolvedValueOnce({});

      await expect(InstallationAuth.getAuthHeaders()).rejects.toThrow(
        'No authentication available'
      );
    });
  });

  describe('Error Handling', () => {
    test('should handle network errors gracefully', async () => {
      (global.fetch as any).mockRejectedValueOnce(new Error('Network error'));

      await expect(InstallationAuth.initialize()).rejects.toThrow(
        'Authentication initialization failed'
      );
    });

    test('should re-register on 401 during refresh', async () => {
      const auth = {
        installationId: 'existing-id',
        token: 'expired-token',
        createdAt: Date.now() - AUTH_CONSTANTS.TOKEN_REFRESH_INTERVAL_MS - 1000,
        lastRefreshed: Date.now() - AUTH_CONSTANTS.TOKEN_REFRESH_INTERVAL_MS - 1000
      };

      mockStorage.get.mockResolvedValueOnce({
        [AUTH_CONSTANTS.STORAGE_KEY]: auth
      });

      // Mock 401 on refresh
      (global.fetch as any).mockResolvedValueOnce({
        ok: false,
        status: AUTH_CONSTANTS.HTTP_STATUS.UNAUTHORIZED,
        text: async () => 'Unauthorized'
      });

      // Mock successful re-registration
      (global.fetch as any).mockResolvedValueOnce({
        ok: true,
        status: AUTH_CONSTANTS.HTTP_STATUS.OK,
        json: async () => ({
          token: 'new-token-after-reauth',
          expiresIn: 3600
        })
      });

      await InstallationAuth.initialize();

      // Verify both refresh and register were called
      expect(global.fetch).toHaveBeenCalledTimes(2);
      expect(global.fetch).toHaveBeenNthCalledWith(1, 
        expect.stringContaining('/auth/refresh'),
        expect.any(Object)
      );
      expect(global.fetch).toHaveBeenNthCalledWith(2,
        expect.stringContaining('/auth/register'),
        expect.any(Object)
      );
    });
  });
});